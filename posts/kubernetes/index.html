<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes | Gabriel Glösmann</title><meta name=keywords content><meta name=description content="Introduction to Kubernetes"><meta name=author content="Gabriel Glösmann"><link rel=canonical href=https://gabrielgloesmann.github.io/posts/kubernetes/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gabrielgloesmann.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://gabrielgloesmann.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gabrielgloesmann.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://gabrielgloesmann.github.io/apple-touch-icon.png><link rel=mask-icon href=https://gabrielgloesmann.github.io/safari_pinned_tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.95.0"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Kubernetes"><meta property="og:description" content="Introduction to Kubernetes"><meta property="og:type" content="article"><meta property="og:url" content="https://gabrielgloesmann.github.io/posts/kubernetes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-09T00:00:00+00:00"><meta property="og:site_name" content="Gabriel Glösmann"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes"><meta name=twitter:description content="Introduction to Kubernetes"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://gabrielgloesmann.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Kubernetes","item":"https://gabrielgloesmann.github.io/posts/kubernetes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes","name":"Kubernetes","description":"Introduction to Kubernetes","keywords":[],"articleBody":"General Kubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It provides a framework for managing distributed systems and ensures that containers are deployed and run efficiently across clusters of computers. Kubernetes abstracts the underlying infrastructure and enables efficient scaling, load balancing, and fault tolerance for applications deployed in containers.\nCluster A Kubernetes cluster is a group of physical or virtual machines (called nodes) running the Kubernetes container orchestration platform. It consists of a master node that manages and coordinates the cluster, and multiple worker nodes that run containerized applications. The master node controls tasks such as scheduling applications, maintaining desired state, and scaling resources. Worker nodes host and run the containers based on instructions from the master node. Kubernetes clusters allow organizations to deploy, manage, and scale containerized applications effectively and resiliently.\nPods A Kubernetes Pod is the smallest deployable and manageable unit in the Kubernetes architecture. It is an abstraction that represents a group of one or more containers running together on a single host and sharing the same network and storage resources. Pods provide a way to encapsulate and manage application components, enabling better resource allocation, scaling, and workload management within a Kubernetes cluster.\nAll containers in a pod have the same ip address (same as the pod) and all pods in a cluster have unique ip addresses in the same ip address space. Every container can communicate with all other containers without NAT and all nodes can communicate with all containers (and vice versa) without NAT. The container share the port space of the pod. The applications in a pod have access to shared volumens.\nNodes A Kubernetes node is a worker machine in a Kubernetes cluster that runs containerized applications. It can be a physical or virtual machine and is responsible for running and managing containers, hosting the necessary services and resources to run applications, such as Docker, kubelet, and networking components. Nodes receive instructions from the control plane and ensure that containers are running as specified, while also providing resources like CPU, memory, and storage for application workloads.\nMaster Node The four components of a master node in a typical Kubernetes cluster are:\n Etcd: Etcd is a distributed key-value store that is used to store the cluster’s configuration data and provides a reliable and highly available data storage solution. It is often used as the backend storage for Kubernetes, including storing information about the cluster state, configuration data, and other metadata. API Server: The API Server is the primary control plane component of Kubernetes and acts as the gateway for all administrative and management operations. It exposes the Kubernetes API, which allows users and other components to interact with the cluster. The API Server handles requests, validates and processes them, and updates the cluster state stored in etcd accordingly. Scheduler: The Scheduler is responsible for assigning pods to nodes in the Kubernetes cluster based on the scheduling requirements and constraints defined in the pod specifications. It monitors the cluster for newly created or pending pods and decides which nodes to place them on, taking into consideration factors like resource availability, quality of service requirements, and various scheduling policies. Controller Manager: The Controller Manager is a component that runs multiple controllers, which are responsible for maintaining the desired cluster state. Each controller focuses on a specific aspect of the system, such as replication, endpoints, services, and more. The controllers continuously monitor the cluster state through the API Server and take corrective actions to reconcile the current state with the desired state defined in the controller logic.  Worker Node The three components of a worker node in a typical Kubernetes cluster are:\n Container Runtime: It manages the execution of containers, such as Docker and provides the environment necessary for running containerized applications. Kubelet: It is an agent that runs on each worker node and is responsible for managing the node and communicating with the Kubernetes control plane. Kubelet ensures that containers are running according to the desired state defined in the cluster. Proxy: It is responsible for network proxying on behalf of the pods. It enables network connectivity and load balancing to the pods from within or outside the cluster by implementing the Kubernetes networking and service abstractions.  Examples Google Cloud Create an Service Account in the GCP and download the json file:\ngcloud iam service-accounts keys create /downloads/terraform.json --iam-account terraform@terraform-ba-154-d25f78b2.iam.gserviceaccount.com ","wordCount":"733","inLanguage":"en","datePublished":"2023-07-09T00:00:00Z","dateModified":"2023-07-09T00:00:00Z","author":{"@type":"Person","name":"Gabriel Glösmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://gabrielgloesmann.github.io/posts/kubernetes/"},"publisher":{"@type":"Organization","name":"Gabriel Glösmann","logo":{"@type":"ImageObject","url":"https://gabrielgloesmann.github.io/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=https://gabrielgloesmann.github.io accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches></span></div><ul id=menu><li><a href=https://gabrielgloesmann.github.io/categories/ title=Information><span>Information</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Kubernetes</h1><div class=post-description>Introduction to Kubernetes</div><div class=post-meta><span title="2023-07-09 00:00:00 +0000 UTC">July 9, 2023</span>&nbsp;·&nbsp;Gabriel Glösmann</div></header><div class=post-content><h1 id=general>General<a hidden class=anchor aria-hidden=true href=#general>#</a></h1><p>Kubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It provides a framework for managing distributed systems and ensures that containers are deployed and run efficiently across clusters of computers. Kubernetes abstracts the underlying infrastructure and enables efficient scaling, load balancing, and fault tolerance for applications deployed in containers.</p><p><img loading=lazy src=/kubernetes-general.png alt="Kubernetes General"></p><h1 id=cluster>Cluster<a hidden class=anchor aria-hidden=true href=#cluster>#</a></h1><p>A Kubernetes cluster is a group of physical or virtual machines (called nodes) running the Kubernetes container orchestration platform. It consists of a master node that manages and coordinates the cluster, and multiple worker nodes that run containerized applications. The master node controls tasks such as scheduling applications, maintaining desired state, and scaling resources. Worker nodes host and run the containers based on instructions from the master node. Kubernetes clusters allow organizations to deploy, manage, and scale containerized applications effectively and resiliently.</p><h1 id=pods>Pods<a hidden class=anchor aria-hidden=true href=#pods>#</a></h1><p>A Kubernetes Pod is the smallest deployable and manageable unit in the Kubernetes architecture. It is an abstraction that represents a group of one or more containers running together on a single host and sharing the same network and storage resources. Pods provide a way to encapsulate and manage application components, enabling better resource allocation, scaling, and workload management within a Kubernetes cluster.</p><p>All containers in a pod have the same ip address (same as the pod) and all pods in a cluster have unique ip addresses in the same ip address space. Every container can communicate with all other containers without NAT and all nodes can communicate with all containers (and vice versa) without NAT. The container share the port space of the pod. The applications in a pod have access to shared volumens.</p><h1 id=nodes>Nodes<a hidden class=anchor aria-hidden=true href=#nodes>#</a></h1><p>A Kubernetes node is a worker machine in a Kubernetes cluster that runs containerized applications. It can be a physical or virtual machine and is responsible for running and managing containers, hosting the necessary services and resources to run applications, such as Docker, kubelet, and networking components. Nodes receive instructions from the control plane and ensure that containers are running as specified, while also providing resources like CPU, memory, and storage for application workloads.</p><p><img loading=lazy src=/kubernetes-master+worker.png alt="Kubernetes Master and Worker"></p><h2 id=master-node>Master Node<a hidden class=anchor aria-hidden=true href=#master-node>#</a></h2><p>The four components of a master node in a typical Kubernetes cluster are:</p><ul><li><strong>Etcd</strong>: Etcd is a distributed key-value store that is used to store the cluster&rsquo;s configuration data and provides a reliable and highly available data storage solution. It is often used as the backend storage for Kubernetes, including storing information about the cluster state, configuration data, and other metadata.</li><li><strong>API Server</strong>: The API Server is the primary control plane component of Kubernetes and acts as the gateway for all administrative and management operations. It exposes the Kubernetes API, which allows users and other components to interact with the cluster. The API Server handles requests, validates and processes them, and updates the cluster state stored in etcd accordingly.</li><li><strong>Scheduler</strong>: The Scheduler is responsible for assigning pods to nodes in the Kubernetes cluster based on the scheduling requirements and constraints defined in the pod specifications. It monitors the cluster for newly created or pending pods and decides which nodes to place them on, taking into consideration factors like resource availability, quality of service requirements, and various scheduling policies.</li><li><strong>Controller Manager</strong>: The Controller Manager is a component that runs multiple controllers, which are responsible for maintaining the desired cluster state. Each controller focuses on a specific aspect of the system, such as replication, endpoints, services, and more. The controllers continuously monitor the cluster state through the API Server and take corrective actions to reconcile the current state with the desired state defined in the controller logic.</li></ul><p><img loading=lazy src=/kubernetes-master.png alt="Kubernetes Master"></p><h2 id=worker-node>Worker Node<a hidden class=anchor aria-hidden=true href=#worker-node>#</a></h2><p>The three components of a worker node in a typical Kubernetes cluster are:</p><ul><li><strong>Container Runtime</strong>: It manages the execution of containers, such as Docker and provides the environment necessary for running containerized applications.</li><li><strong>Kubelet</strong>: It is an agent that runs on each worker node and is responsible for managing the node and communicating with the Kubernetes control plane. Kubelet ensures that containers are running according to the desired state defined in the cluster.</li><li><strong>Proxy</strong>: It is responsible for network proxying on behalf of the pods. It enables network connectivity and load balancing to the pods from within or outside the cluster by implementing the Kubernetes networking and service abstractions.</li></ul><p><img loading=lazy src=/kubernetes-worker.png alt="Kubernetes Worker"></p><h1 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h1><h2 id=google-cloud>Google Cloud<a hidden class=anchor aria-hidden=true href=#google-cloud>#</a></h2><p>Create an Service Account in the <a href=Google-Cloud.md>GCP</a> and download the <code>json</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gcloud iam service-accounts keys create /downloads/terraform.json --iam-account terraform@terraform-ba-154-d25f78b2.iam.gserviceaccount.com 
</span></span></code></pre></div></div><footer class=post-footer><nav class=paginav><a class=prev href=https://gabrielgloesmann.github.io/posts/latex/><span class=title>« Prev Page</span><br><span>LateX</span></a>
<a class=next href=https://gabrielgloesmann.github.io/posts/json/><span class=title>Next Page »</span><br><span>JSON</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://gabrielgloesmann.github.io>Gabriel Glösmann</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>